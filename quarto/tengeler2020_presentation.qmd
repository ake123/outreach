---
title: "A TreeSE Tutorial with Tengeler2020"
format: revealjs
editor: visual
smaller: true
---

```{r}
#| label: setup
#| include: false
library(mia)
library(vegan)
library(scater)
library(dplyr)
library(ComplexHeatmap)
library(patchwork)
data("Tengeler2020", package = "mia")
```

## Study design {.scrollable}

. . .

Tengeler2020 is a TreeSummarizedExperiment from a study on the effects of gut microbiome on Attention-deficit/hyperactivity disorder (ADHD) in humanised mice.

```{r}
#| label: import-data
#| echo: true
data("Tengeler2020", package = "mia")
tse <- Tengeler2020
tse
```

. . .

::: columns
::: {.column width="48%"}
Young, male, germ-free C57BL/6JOlaHsd mice (n = 27) were humanised with gut microbiome from either ADHD patients (n = 3) or healthy controls (n = 3) of matched age. Notably, the mice belonged to three different cohorts.
:::

::: {.column width="52%"}
```{r}
#| label: tab-pop
tab <- table(colData(tse)$patient_status, colData(tse)$cohort)
colnames(tab) <- c("Cohort1", "Cohort2", "Cohort3")
knitr::kable(tab)
```
:::
:::

Microbiome data was obtained by 16S rRNA gene sequencing of bacterial DNA sampled from faecal pellet on a weekly basis. Then, sequence reads were assembled into Operational Taxonomic Units (OTUs) with an NG-Tax pipeline.

## Community composition

. . .

### Assay transformation and agglomeration

. . .

First off, we transform the counts assay to relative abundances and store the new assay back in the TreeSE.

```{r}
#| label: transform-relabundance
#| echo: true
tse <- transformCounts(tse, method = "relabundance")
```

. . .

Relative abundances are useful because they are not affected by compositionality, which is present in the counts assay due to sequencing bias (the unequal amplification of DNA from two different samples due to random effects).

```{r}
#| label: tbl-top
#| tbl-cap: Relative abundance (%) of bacterial phyla grouped by patient status.
tse_phylum <- agglomerateByRank(tse, rank = "Phylum")

tse_list <- splitOn(tse_phylum, f = "patient_status")

top_tab_list <- lapply(tse_list, function(tse) round(rowMeans(assay(tse, "relabundance")[getTopTaxa(tse, top = 4L), ]) * 100, 1))

knitr::kable(cbind(top_tab_list[[1]], top_tab_list[[2]]), col.names = c("ADHD", "Control"))
```

. . .

Next, we agglomerate the experiment to the Order level, so that information is more condensed and therefore easier to visualise and interpret.

```{r}
#| label: agglomerate-order
#| echo: true
tse_order <- agglomerateByRank(tse, rank = "Order")
```

. . .

### Compositional heatmap

. . .

We then perform a CLR transformation sample-wise and a Z transformation feature-wise. The former creates a more homogeneous (logarithmic) scale for the usually very skewed microbiome data, whereas the latter normalises the features across samples for better comparisons between samples.

```{r}
#| label: transform-clrz
#| echo: true
# transform relative abundance to clr
tse_order <- transformCounts(tse_order,
                             assay.type = "relabundance",
                             method = "clr",
                             pseudocount = 1,
                             MARGIN = "samples")

# transform clr to z
tse_order <- transformCounts(tse_order,
                             assay.type = "clr", 
                             method = "z",
                             name = "clr_z",
                             MARGIN = "features")
```

. . .

Finally, we plot the compositional heatmap with the ComplexHeatmap package and illustrate it in @fig-compheat.

```{r}
#| label: fig-compheat
#| fig-cap: Heatmap of CLR-Z transformed microbiome assay where columns correspond to samples and rows to taxa agglomerated by order.
#| echo: true
Heatmap(assay(tse_order, "clr_z"),
        name = "clr-z")
```

. . .

## Alpha diversity {.scrollable}

. . .

We calculate alpha diversity in terms of coverage, Shannon and inverse Simpson indices based on the counts assay. These three indices differ from one another in how much weight they give to rare taxa: coverage considers all taxa equally important, whereas Shannon and - even more - Simpson give more importance to abundant taxa.

```{r}
#| label: estimate-diversity
#| echo: true
tse <- estimateDiversity(tse,
                         assay.type = "counts",
                         index = c("coverage", "shannon", "inverse_simpson"))
```

. . .

Next, we plot the three indices, with patient status on the x axis and alpha diversity on the y axis. We can also colour by cohort to control for batch effects.

```{r}
#| label: plot-alpha
#| echo: true
p_coverage <- plotColData(tse, "coverage", "patient_status",
                          colour_by = "cohort", show_median = TRUE) +
  labs(x = "Patient Status")

p_shannon <- plotColData(tse, "shannon", "patient_status",
                         colour_by = "cohort", show_median = TRUE) +
  labs(x = "Patient Status")

p_simpson <- plotColData(tse, "inverse_simpson", "patient_status",
                         colour_by = "cohort", show_median = TRUE) +
  labs(x = "Patient Status")
```

. . .

The three metrics for alpha diversity follow different scales, but they seem to agree when comparing the distributions of the two patient groups (see @fig-alpha).

```{r}
#| label: fig-alpha
#| fig-cap: Box plots of (A) coverage (B) Shannon and (C) inverse Simpson indices grouped by patient status and coloured by cohort.
p <- (p_coverage | p_shannon | p_simpson) +
  plot_layout(guides = "collect")
p
```

## Beta diversity {.scrollable}

. . .

### Principal Coordinate Analysis (PCoA)

. . .

PCoA is a method to choose the dimensions of the data that explain most of the variance in the data. Distances between samples can be expressed by several ecological indices, such as Bray-Curtis and Aitchison dissimilarities.

. . .

Here, we run multi-dimensional scaling (a type of PCoA) with Bray-Curtis dissimilarity and based on the relabundance assay.

```{r}
#| label: run-bray
#| echo: true
tse <- runMDS(tse,
              FUN = vegan::vegdist,
              method = "bray",
              name = "Bray",
              assay.type = "relabundance")
```

. . .

We then visualise the first two dimensions.

```{r}
#| label: plot-bray
#| echo: true
p1 <- plotReducedDim(tse, "Bray",
                     colour_by = "patient_status",
                     shape_by = "cohort")
```

```{r}
#| label: prep-bray
e <- attr(reducedDim(tse, "Bray"), "eig")
rel_eig <- e / sum(e[e > 0])

p1 <- p1 + labs(x = paste("Bray 1 (", round(100 * rel_eig[[1]], 1), "%", ")", sep = ""),
                y = paste("Bray 2 (", round(100 * rel_eig[[2]], 1), "%", ")", sep = ""))
```

. . .

```{r}
#| label: fg-bray
#| fig-width: 6
#| fig-asp: 0.7
#| fig-align: center
p1
```

. . .

```{r}
#| label: run-unifrac
#| echo: true
tse <- runMDS(tse,
              FUN = mia::calculateUnifrac,
              name = "Unifrac",
              tree = rowTree(tse),
              ntop = nrow(tse),
              assay.type = "counts")
```

. . .

```{r}
#| label: plot-unifrac
#| echo: true
p2 <- plotReducedDim(tse, "Unifrac",
                     colour_by = "patient_status",
                     shape_by = "cohort")
```

```{r}
e <- attr(reducedDim(tse, "Unifrac"), "eig")
rel_eig <- e / sum(e[e > 0])

p2 <- p2 + labs(x = paste("Unifrac 1 (", round(100 * rel_eig[[1]], 1), "%", ")", sep = ""),
                y = paste("Unifrac 2 (", round(100 * rel_eig[[2]], 1), "%", ")", sep = ""))
```

. . .

```{r}
#| label: fg-unifrac
#| fig-width: 7
#| fig-asp: 0.7
#| fig-align: center
p2
```

. . .

Finally, we combine the two plots with the patchwork syntax and compare them in @fig-beta.

```{r}
#| label: fig-beta
#| fig-cap: Ordination plots based on (A) Bray-Curtis or (B) Unifrac index. Samples are coloured by patient status and shaped by cohort.
#| echo: true
(p1 | p2) +
  plot_layout(guides = "collect") +
  plot_annotation(tag_levels = "A")
```

. . .

It is also possible to specify the number of output dimensions with the argument `ncomponents`. Here, we show it with the UMAP ordination method.

```{r}
#| label: run-umap
#| echo: true
tse <- runUMAP(tse,
               assay.type = "counts",
               ncomponents = 3)
```

. . .

We then plot all three dimensions, but you could also plot a pair of dimensions (1 and 3, 2 and 3 or 1 and 2) with the argument `ncomponents`.

```{r}
#| label: plot-umap
#| echo: true
p <- plotReducedDim(tse, "UMAP",
                    ncomponents = 1:3,
                    colour_by = "patient_status",
                    shape_by = "cohort")
```

. . .

```{r}
#| label: fig-umap
#| fig-cap: UMAP plot of the first three dimensions.
p
```

## Beta diversity {.scrollable}

. . .

### distance-based Redundance Analysis (dbRDA)

. . .

```{r}
#| label: run-brayrda
#| echo: true
tse <- runRDA(tse,
              formula = assay ~ patient_status + cohort,
              FUN = vegan::vegdist,
              method = "bray",
              assay.type = "relabundance")
```

. . .

```{r}
#| label: plot-brayrda
#| echo: true
p <- plotReducedDim(tse, "RDA",
                    colour_by = "patient_status",
                    shape_by = "cohort")
```

. . .

```{r}
#| label: fig-brayrda
#| fig-cap: RDA plot with Bray-Curtis dissimilarity.
#| fig-width: 7
#| fig-asp: 0.7
#| fig-align: center
p
```

. . .

```{r}
#| label: aitchison-workflow
#| echo: true

# perform clr transformation
tse <- transformCounts(tse,
                       assay.type = "relabundance",
                       method = "clr",
                       pseudocount = 1)

# run RDA
tse <- runRDA(tse,
              formula = assay ~ patient_status + cohort,
              FUN = vegan::vegdist,
              method = "euclidean",
              assay.type = "clr",
              name = "Aitchison")

# plot RDA
p <- plotReducedDim(tse, "Aitchison",
                    colour_by = "patient_status",
                    shape_by = "cohort")
```

. . .

```{r}
#| label: fig-aitchirda
#| fig-cap: RDA plot with Aitchison distance (CLR assay + Euclidian distance).
#| fig-width: 7
#| fig-asp: 0.7
#| fig-align: center
p
```

. . .

```{r}
#| label: test-rda
#| echo: true
rda <- attr(reducedDim(tse, "RDA"), "rda")

set.seed(123)
terms_permanova <- anova.cca(rda,
                             permutations = 99)

set.seed(123)
margin_permanova <- anova.cca(rda,
                              by = "margin",
                              permutations = 99)
```

. . .

```{r}
#| label: tbl-permanova
#| tbl-cap: Results of PERMANOVA on patient_status and cohort groups.
rda_info <- as.data.frame(rbind(terms_permanova["Model", ], margin_permanova))

rda_info[ , "Total variance"] <- rda_info["Model", "SumOfSqs"] + rda_info["Residual", "SumOfSqs"]

rda_info[ , "Explained variance"] <- rda_info[ , "SumOfSqs"] / rda_info[ , "Total variance"]

knitr::kable(rda_info)
```

. . .

```{r}
#| label: test-homogeneity
#| echo: true
homo1 <- anova(betadisper(vegdist(t(assay(tse, "relabundance"))), tse$patient_status))
homo2 <- anova(betadisper(vegdist(t(assay(tse, "relabundance"))), tse$cohort))
```

. . .

```{r}
#| label: tbl-homogeneity
#| tbl-cap: Results of betadisper test on homogeneity.
homogeneity <- as.data.frame(rbind(patient_status = homo1["Groups", ],
                                   cohort = homo2["Groups", ]))

knitr::kable(homogeneity)
```

. . .

```{r}
#| label: plot-rda
library(ggord)
library(ggplot2)
library(stringr)

coldata <- colData(tse)
variable_names <- c("patient_status", "cohort")

vec_lab_old <- rownames(rda$CCA$biplot)

vec_lab <- sapply(vec_lab_old, FUN = function(name){
    variable_name <- variable_names[ str_detect(name, variable_names) ]
    if( !any(name %in% variable_names) ){
        group_name <- unique( coldata[[variable_name]] )[ 
        which( paste0(variable_name, unique( coldata[[variable_name]] )) == name ) ]
        new_name <- paste0(variable_name, " \U2012 ", group_name)
    } else{
        new_name <- name
    }
    new_name <- expr(paste(!!new_name, " (", 
                           !!format(round( rda_info[variable_name, "Explained variance"]*100, 1), nsmall = 1), 
                           "%, ",italic("P"), " = ", 
                           !!gsub("0\\.","\\.", format(round( rda_info[variable_name, "Pr(>F)"], 3), 
                                                       nsmall = 3)), ")"))

    return(new_name)
})
names(vec_lab) <- vec_lab_old

xlab <- paste0("RDA1 (", format(round( rda$CCA$eig[[1]]/rda$CCA$tot.chi*100, 1), nsmall = 1 ), "%)")
ylab <- paste0("RDA2 (", format(round( rda$CCA$eig[[2]]/rda$CCA$tot.chi*100, 1), nsmall = 1 ), "%)")

plot <- ggord(rda, grp_in = coldata[["patient_status"]], vec_lab = vec_lab,
              alpha = 0.5,
              size = 4, addsize = -4,
              txt = 3.5, repel = TRUE, 
          ) + 
    guides(colour = guide_legend("patient_status"),
           fill = guide_legend("patient_status"),
           group = guide_legend("patient_status"),
           shape = guide_legend("patient_status"),
           x = guide_axis(xlab),
           y = guide_axis(ylab)) +
    theme( axis.title = element_text(size = 10) )
```

```{r}
#| label: fig-arrows
#| fig-cap: RDA plot of samples coloured by patient status. The arrows indicate the percentage of variance in beta diversity explained by the patient status or cohort and the respective p-value.
#| fig-width: 12
#| fig-height: 5
#| fig-align: center
plot
```

# The end
